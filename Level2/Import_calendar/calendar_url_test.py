# Generated by Selenium IDE
import pytest
import time
import json
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
import os
import sys
parent_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
sys.path.append(parent_dir)
from prepare_for_test import TestAutomationHelper
from selenium.webdriver.support import expected_conditions as EC
INPUT_PATH = os.path.join(os.path.dirname(__file__), "Input_calendar_url_test.json")
PREPARED_CONFIG_PATH = os.path.join(os.path.dirname(__file__), '..', "prepare_for_test.json")
INPUT_CONFIG_PATH = os.path.join(os.path.dirname(__file__), '..', "Config.json")
def get_authen_info():
  with open(INPUT_PATH, 'r') as f:
    combined_data = json.load(f)
  # Lấy dữ liệu authen
  authen_data = combined_data.get('authen', [])  # Dùng get để tránh lỗi nếu key không tồn tại
  return authen_data
def get_test_data():
  with open(INPUT_PATH, 'r') as f:
    combined_data = json.load(f)
  test_url_data = combined_data.get('url_data', [])
  # Lấy dữ liệu test
  return [(d["name"], d["url"], d["expected"]) for d in test_url_data]
class TestTC001001():
  def setup_method(self, method):
    options = webdriver.ChromeOptions()
    options.add_argument('--no-sandbox')
    options.add_argument('--disable-dev-shm-usage')
    options.add_argument("--inprivate")
    self.driver = webdriver.Chrome(options=options)
    self.vars = {}
  
  def teardown_method(self, method):
    self.driver.quit()
  
  def precondition(self):
    helper = TestAutomationHelper(self.driver)
    helper.execute_action("login", PREPARED_CONFIG_PATH)
    helper.execute_action("go_to_import_calendar_page", PREPARED_CONFIG_PATH)    
  def log_out(self):
    helper = TestAutomationHelper(self.driver)
    helper.execute_action("logout", PREPARED_CONFIG_PATH)
  def load_config(self, test_name):
    """Load configuration data for a specific test."""
    with open(INPUT_CONFIG_PATH, 'r') as f:
        data = json.load(f)
    for test_case in data:
        if test_case["test_name"] == test_name:
            return test_case
    raise ValueError(f"Test name '{test_name}' not found in configuration file.")
  def execute_steps(self, name=None, url=None):
    steps = self.load_config("carlendar_url_test").get("steps", [])
    for step in steps:
      method = step['method']
      value = step['value']
      action = step['action']
      data = step['data']
      print(data, value)
      # Determine the Selenium locator
      locator = getattr(By, method)

      # Execute action based on the action type
      if action == "click":
        element = WebDriverWait(self.driver, 15).until(
          EC.element_to_be_clickable((locator, value))
        )
        element.click()
      elif action == "send_keys":
        time.sleep(3)
        element = self.driver.find_element(locator, value)
        if data == "name":
          element.send_keys(name)
        elif data == "url":
          print(url)
          #file = os.path.abspath(file)
          element.send_keys(url) 
  @pytest.mark.parametrize("name, url, expected", get_test_data())
  def test_calendar_url(self, name, url, expected):
    self.precondition()
    self.execute_steps(name, url)
    verify = self.load_config("carlendar_url_test").get("verify", [])
    for verify in verify:
      if verify.get("expected") == expected:
        WebDriverWait(self.driver, 5).until(
          EC.visibility_of_element_located((By.XPATH, verify.get("xpath")))
        )
        assert True
    self.log_out()
    
  
  
